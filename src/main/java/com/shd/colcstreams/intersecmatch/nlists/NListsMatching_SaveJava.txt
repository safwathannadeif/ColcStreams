package com.shd.colcstreams.intersecmatch.nlists;
import com.shd.data.Student;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class NListsMatching<NXElm,N1XElm> {
    public Function<NXElm, String> xElmMakeKeyFunci = (xElm) -> xElm.toString();
    protected Function<NXElm, String> getxElmMakeKeyFunci() {
        return xElmMakeKeyFunci;
    }
    protected void setxElmMakeKeyFunci(Function<NXElm, String> xElmMakeKeyFuncii) {
        System.out.println("setxElmMakeKeyFunci from NListsMatching done.......... ") ;
        xElmMakeKeyFunci = xElmMakeKeyFuncii ;
    }
    private final BiConsumer<NXElm, Map<String, List<NXElm>>>  accumMatchi = (nxelm, mapLis) -> {

            String keyStr = getxElmMakeKeyFunci().apply(nxelm);
            List<NXElm> lisOFXelm = mapLis.get(keyStr);
            if (lisOFXelm == null) {
                System.out.println("lisOFXelm= null") ;
                lisOFXelm = new ArrayList<NXElm>();
                mapLis.put(keyStr, lisOFXelm);
            }
            else {
                System.out.println("lisOFXelm!= NOT NOT null") ;
            }
            lisOFXelm.add(nxelm);
        } ;




    private final BiConsumer<List<NXElm>, Map<String, List<NXElm>>>  OldaccumMatchi = (lis, mapLis) -> {
        lis.stream().peek(nxelm -> {
            String keyStr = getxElmMakeKeyFunci().apply(nxelm);
            List<NXElm> lisOFXelm = mapLis.get(keyStr);
            if (lisOFXelm == null) {
                System.out.println("lisOFXelm= null") ;
                lisOFXelm = new ArrayList<NXElm>();
                mapLis.put(keyStr, lisOFXelm);
            }
            lisOFXelm.add(nxelm);
        })
        ;
    };
    // For Short list this simple match is Ok. For Long Lists with a million of records,
    // LongListsMatchingAndDistinct generic implemented in this package is the right one
    @FunctionalInterface
    public interface MatchingNListsFunction<NXElm,N1XElm> {
        N1XElm matchNLsits(NXElm lisOfLis);
        //List<XElm> matchLists(List<XElm> a1, List<XElm> a2, BiPredicate a3);
    }
    //Matching2ListsFunction is a Generic Function for simple Matching
    //Function implementations for any Type/XElm is implemented here and var parameter instance passed as implemented function (BiPredicate)
    // for Example Student Type call this function with List1<Student> , List2<Student> ,  and BiPredicate instance function
    public MatchingNListsFunction<List<List<NXElm>>,List<NXElm>> matching2ListsFunction = (listOfLists) ->
    {
        List<NXElm> lisouti = new ArrayList<NXElm>();
        Map<String, List<NXElm>> map4StudLis = new HashMap();
        listOfLists.stream().flatMap(x -> x.stream()).forEach(nxlem-> {
                System.out.println("InsidePeek" + nxlem.toString() ) ;
                accumMatchi.accept(nxlem, map4StudLis);
                });

        return (map4StudLis.entrySet().stream().map(inp -> inp.getValue())
               //  .peek(ll-> System.out.println(ll.size()))
                .filter( (lis->(lis.size()) > 1 ))
                .flatMap(x -> x.stream()).collect(Collectors.toList())) ;


    };
}
/*** this one working without the filter ????? */
// return (map4StudLis.entrySet().stream().map(inp -> inp.getValue())
//         //.filter(lis->lisouti.size()>1)
//         .flatMap(x -> x.stream()).collect(Collectors.toList())) ;

















